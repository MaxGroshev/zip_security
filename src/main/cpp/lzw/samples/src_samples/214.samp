    audited = Nullability.size() > 0 || ReturnNullability;
    if (audited)
      OutInfo.addTypeInfo(0, ReturnNullability ? *ReturnNullability
                                               : NullabilityKind::NonNull);
    if (!audited)
      return;
    OutInfo.NullabilityAudited = audited;
    OutInfo.NumAdjustedNullable = idx;
  }

  /// Convert the common parts of an entity from YAML.
  template <typename T>
  void convertCommonEntity(const T &Common, CommonEntityInfo &Info,
                           StringRef APIName) {
    convertAvailability(Common.Availability, Info, APIName);
    Info.setSwiftPrivate(Common.SwiftPrivate);
    Info.SwiftName = std::string(Common.SwiftName);
  }

  /// Convert the common parts of a type entity from YAML.
  template <typename T>
  void convertCommonType(const T &Common, CommonTypeInfo &Info,
                         StringRef APIName) {
    convertCommonEntity(Common, Info, APIName);
    if (Common.SwiftBridge)
      Info.setSwiftBridge(std::string(*Common.SwiftBridge));
    Info.setNSErrorDomain(Common.NSErrorDomain);
  }

  // Translate from Method into ObjCMethodInfo and write it out.
  void convertMethod(const Method &M, ContextID ClassID, StringRef ClassName,
                     VersionTuple SwiftVersion) {
    ObjCMethodInfo MI;
    convertCommonEntity(M, MI, M.Selector);

    // Check if the selector ends with ':' to determine if it takes arguments.
    bool takesArguments = M.Selector.ends_with(":");

    // Split the selector into pieces.
    llvm::SmallVector<StringRef, 4> Args;
    M.Selector.split(Args, ":", /*MaxSplit*/ -1, /*KeepEmpty*/ false);
    if (!takesArguments && Args.size() > 1) {
      emitError("selector '" + M.Selector + "' is missing a ':' at the end");
      return;
    }

    // Construct ObjCSelectorRef.
    api_notes::ObjCSelectorRef Selector;
    Selector.NumArgs = !takesArguments ? 0 : Args.size();
    Selector.Identifiers = Args;
