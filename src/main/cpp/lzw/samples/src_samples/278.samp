  if (auto *Eval = Init.dyn_cast<EvaluatedStmt *>()) {
    Eval->~EvaluatedStmt();
    getASTContext().Deallocate(Eval);
  }

  Init = I;
}

bool VarDecl::mightBeUsableInConstantExpressions(const ASTContext &C) const {
  const LangOptions &Lang = C.getLangOpts();

  // OpenCL permits const integral variables to be used in constant
  // expressions, like in C++98.
  if (!Lang.CPlusPlus && !Lang.OpenCL && !Lang.C23)
    return false;

  // Function parameters are never usable in constant expressions.
  if (isa<ParmVarDecl>(this))
    return false;

  // The values of weak variables are never usable in constant expressions.
  if (isWeak())
    return false;

  // In C++11, any variable of reference type can be used in a constant
  // expression if it is initialized by a constant expression.
  if (Lang.CPlusPlus11 && getType()->isReferenceType())
    return true;

  // Only const objects can be used in constant expressions in C++. C++98 does
  // not require the variable to be non-volatile, but we consider this to be a
  // defect.
  if (!getType().isConstant(C) || getType().isVolatileQualified())
    return false;

  // In C++, but not in C, const, non-volatile variables of integral or
  // enumeration types can be used in constant expressions.
  if (getType()->isIntegralOrEnumerationType() && !Lang.C23)
    return true;

  // C23 6.6p7: An identifier that is:
  // ...
  // - declared with storage-class specifier constexpr and has an object type,
  // is a named constant, ... such a named constant is a constant expression
  // with the type and value of the declared object.
  // Additionally, in C++11, non-volatile constexpr variables can be used in
  // constant expressions.
  return (Lang.CPlusPlus11 || Lang.C23) && isConstexpr();
}

