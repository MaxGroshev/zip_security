    // Write all enumerators.
    llvm::StringSet<> KnownEnumConstants;
    for (const auto &EnumConstant : TLItems.EnumConstants) {
      // Check for duplicate enumerators
      if (!KnownEnumConstants.insert(EnumConstant.Name).second) {
        emitError(llvm::Twine("multiple definitions of enumerator '") +
                  EnumConstant.Name + "'");
        continue;
      }

      EnumConstantInfo ECI;
      convertAvailability(EnumConstant.Availability, ECI, EnumConstant.Name);
      ECI.setSwiftPrivate(EnumConstant.SwiftPrivate);
      ECI.SwiftName = std::string(EnumConstant.SwiftName);
      Writer.addEnumConstant(EnumConstant.Name, ECI, SwiftVersion);
    }

    // Write all tags.
    llvm::StringSet<> KnownTags;
    for (const auto &Tag : TLItems.Tags) {
      // Check for duplicate tag definitions.
      if (!KnownTags.insert(Tag.Name).second) {
        emitError(llvm::Twine("multiple definitions of tag '") + Tag.Name +
                  "'");
        continue;
      }

      TagInfo TI;
      convertCommonType(Tag, TI, Tag.Name);

      if ((Tag.SwiftRetainOp || Tag.SwiftReleaseOp) && !Tag.SwiftImportAs) {
        emitError(llvm::Twine("should declare SwiftImportAs to use "
                              "SwiftRetainOp and SwiftReleaseOp (for ") +
                  Tag.Name + ")");
        continue;
      }
      if (Tag.SwiftReleaseOp.has_value() != Tag.SwiftRetainOp.has_value()) {
        emitError(llvm::Twine("should declare both SwiftReleaseOp and "
                              "SwiftRetainOp (for ") +
                  Tag.Name + ")");
        continue;
      }

      if (Tag.SwiftImportAs)
        TI.SwiftImportAs = Tag.SwiftImportAs;
      if (Tag.SwiftRetainOp)
        TI.SwiftRetainOp = Tag.SwiftRetainOp;
      if (Tag.SwiftReleaseOp)
        TI.SwiftReleaseOp = Tag.SwiftReleaseOp;

