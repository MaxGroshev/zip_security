public:
  YAMLConverter(const Module &TheModule, const FileEntry *SourceFile,
                llvm::raw_ostream &OS,
                llvm::SourceMgr::DiagHandlerTy DiagHandler,
                void *DiagHandlerCtxt)
      : M(TheModule), Writer(TheModule.Name, SourceFile), OS(OS),
        DiagHandler(DiagHandler), DiagHandlerCtxt(DiagHandlerCtxt),
        ErrorOccured(false) {}

  void convertAvailability(const AvailabilityItem &Availability,
                           CommonEntityInfo &CEI, llvm::StringRef APIName) {
    // Populate the unavailability information.
    CEI.Unavailable = (Availability.Mode == APIAvailability::None);
    CEI.UnavailableInSwift = (Availability.Mode == APIAvailability::NonSwift);
    if (CEI.Unavailable || CEI.UnavailableInSwift) {
      CEI.UnavailableMsg = std::string(Availability.Msg);
    } else {
      if (!Availability.Msg.empty())
        emitError(llvm::Twine("availability message for available API '") +
                  APIName + "' will not be used");
    }
  }

  void convertParams(const ParamsSeq &Params, FunctionInfo &OutInfo) {
    for (const auto &P : Params) {
      ParamInfo PI;
      if (P.Nullability)
        PI.setNullabilityAudited(*P.Nullability);
      PI.setNoEscape(P.NoEscape);
      PI.setType(std::string(P.Type));
      PI.setRetainCountConvention(P.RetainCountConvention);
      if (OutInfo.Params.size() <= P.Position)
        OutInfo.Params.resize(P.Position + 1);
      OutInfo.Params[P.Position] |= PI;
    }
  }

  void convertNullability(const NullabilitySeq &Nullability,
                          std::optional<NullabilityKind> ReturnNullability,
                          FunctionInfo &OutInfo, llvm::StringRef APIName) {
    if (Nullability.size() > FunctionInfo::getMaxNullabilityIndex()) {
      emitError(llvm::Twine("nullability info for '") + APIName +
                "' does not fit");
      return;
    }

    bool audited = false;
    unsigned int idx = 1;
    for (const auto &N : Nullability)
      OutInfo.addTypeInfo(idx++, N);
