      if (Tag.EnumConvenienceKind) {
        if (Tag.EnumExtensibility) {
          emitError(
              llvm::Twine("cannot mix EnumKind and EnumExtensibility (for ") +
              Tag.Name + ")");
          continue;
        }
        if (Tag.FlagEnum) {
          emitError(llvm::Twine("cannot mix EnumKind and FlagEnum (for ") +
                    Tag.Name + ")");
          continue;
        }
        switch (*Tag.EnumConvenienceKind) {
        case EnumConvenienceAliasKind::None:
          TI.EnumExtensibility = EnumExtensibilityKind::None;
          TI.setFlagEnum(false);
          break;
        case EnumConvenienceAliasKind::CFEnum:
          TI.EnumExtensibility = EnumExtensibilityKind::Open;
          TI.setFlagEnum(false);
          break;
        case EnumConvenienceAliasKind::CFOptions:
          TI.EnumExtensibility = EnumExtensibilityKind::Open;
          TI.setFlagEnum(true);
          break;
        case EnumConvenienceAliasKind::CFClosedEnum:
          TI.EnumExtensibility = EnumExtensibilityKind::Closed;
          TI.setFlagEnum(false);
          break;
        }
      } else {
        TI.EnumExtensibility = Tag.EnumExtensibility;
        TI.setFlagEnum(Tag.FlagEnum);
      }

      Writer.addTag(Ctx, Tag.Name, TI, SwiftVersion);
    }

    // Write all typedefs.
    llvm::StringSet<> KnownTypedefs;
    for (const auto &Typedef : TLItems.Typedefs) {
      // Check for duplicate typedef definitions.
      if (!KnownTypedefs.insert(Typedef.Name).second) {
        emitError(llvm::Twine("multiple definitions of typedef '") +
                  Typedef.Name + "'");
        continue;
      }

      TypedefInfo TInfo;
      convertCommonType(Typedef, TInfo, Typedef.Name);
